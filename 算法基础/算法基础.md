

# 																		算法基础



## 排序



### 快速排序

- **分治**

- **时间复杂度**：这种划分方式在平均情况下时间复杂度为 **O(nlogn**)，空间复杂度为 **O(logn)**。最坏情况为数组已排好序或者数组中的数都相等，此时每次划分只会将数组的长度减少1，会递归 n 次，导致时间复杂度为 O(n2)，空间复杂度为 O(n)。

  

1. 选取pivot
2. 划分，根据选取的pivot将数组划分成小于pivot的部分和大于pivot的部分
3. 递归求解小于pivot和大于pivot的部分

> 开辟两个额外空间（空间开销大）



> 两个左右指针，L，R；



```java
import java.util.Scanner;

public class 快排 {
    private static int[] q;

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        q = new int[n];
        for (int i = 0; i < n; i++) {
            q[i] = sc.nextInt();
        }
        quick_sort(q, 0, n - 1);
        for (int i = 0; i < n; i++)
            System.out.print(q[i] + " ");
    }

    public static void quick_sort(int[] q, int l, int r) {
        if (l >= r)
            return;
        int x = q[(l + r) / 2];
        int i = l - 1, j = r + 1;
        while (i < j) {
            do {
                i++;
            } while (q[i] < x);
            do {
                j--;
            } while (q[j] > x);
            if (i < j) {
                int temp = q[i];
                q[i] = q[j];
                q[j] = temp;
            }
        }
        quick_sort(q, l, j);
        quick_sort(q, j + 1, r);
    }
}

```

- [ ] ACWING题目：https://www.acwing.com/problem/content/787/
- [ ] ACWING题目：https://www.acwing.com/problem/content/788/





### 归并排序

- **分治**

- 时间复杂度：**nlogn**

  ![image-20211004164928243](F:\typora\image\image-20211004164928243.png)





1. 确定分界点：mid=（left+right）/2
2. 递归排序	left和right
3. 把小的放到数组当中
4. 归并——合二为一



```java
import java.util.Scanner;

public class 归并排序 {
    private static int[] array;

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        array = new int[n];
        for (int i = 0; i < n; i++) {
            array[i] = sc.nextInt();
        }
        merge_sort(array, 0, n - 1);
        for (int i = 0; i < n; i++)
            System.out.print(array[i] + " ");
    }

    public static void merge_sort(int[] array, int l, int r) {
        if (l >= r) return;
        int mid = l + r >> 1;
        merge_sort(array, l, mid);
        merge_sort(array, mid + 1, r);
        int[] ans = new int[array.length];
        int i = l, j = mid + 1, k = 0;
        while (i <= mid && j <= r) {
            if (array[i] < array[j]) ans[k++] = array[i++];
            else ans[k++] = array[j++];
        }
        while (i <= mid) ans[k++] = array[i++];
        while (j <= r) ans[k++] = array[j++];
        for (i = l, j = 0; i <= r; i++, j++) {
            array[i] = ans[j];
        }
    }
}
```



- [ ] ACWING题目：https://www.acwing.com/problem/content/789/

  





## 二分

- 用于已经排好序的数组

整数二分

- 边界问题


> mid=（l+r+1）/2  ；l=mid||r=mid-1；
>
> mid=（l+r）/2；l=mid+1||r=mid；



```java
package 二分;

public class 二分查找 {
    static int[] array;

    public static void main(String[] args) {
        array = new int[]{1, 2, 3, 4, 5};
        System.out.println(bSearch1(array, 4));
        System.out.println(bSearch2(array, 2));
    }

    public static int bSearch1(int[] array, int x) {
        int left = 0;
        int right = array.length - 1;
        while (left < right) {
            int mid = left + right >> 1;
            if (array[mid] >= x) right = mid;
            else left = mid + 1;
        }
        if (array[left] == x)
            return left;
        return -1;
    }

    public static int bSearch2(int[] array, int x) {
        int left = 0;
        int right = array.length - 1;
        while (left < right) {
            int mid = left + right + 1 >> 1;
            if (array[mid] <= x) left = mid;
            else right = mid - 1;
        }
        if (array[left] == x)
            return left;
        return -1;
    }
}

```





浮点数二分

> 通过控制r-l来控制精度
>
> 或者通过循环迭代（循环多次）

```java
import java.util.Scanner;

public class 浮点数二分 {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        double x = sc.nextDouble();
        double l = 0;
        double r = x;
        while (r - l > 1e-4) {
            double mid = (l + r) / 2;
            if (mid * mid >= x) r = mid;
            else l = mid;
        }
        System.out.println(l);
    }
}

```



- [ ] ACWING题目：https://www.acwing.com/problem/content/791/
- [ ] ACWING题目：https://www.acwing.com/problem/content/792/





[周赛二分题](https://leetcode-cn.com/problems/minimized-maximum-of-products-distributed-to-any-store/)

```java
package Competition;

import java.util.Arrays;

public class LC5920 {
    public int minimizedMaximum(int n, int[] quantities) {
        int l = 1;
        int r = Arrays.stream(quantities).max().getAsInt();
        System.out.println(r);
        while (l < r) {
            int mid = l + r >> 1;
            int cnt = 0;
            for (int x : quantities) {
                cnt += (x - 1) / mid + 1;//向上取整
            }
            if (cnt <= n)
                r = mid;
            else
                l = mid + 1;
        }
        return l;
    }
}

```





## 高精度



**BigInteger**

```java
BigInteger a=new BigInteger(b);

1.valueOf(parament); 将参数转换为制定的类型

比如 int a=3;

BigInteger b=BigInteger.valueOf(a);

则b=3;

String s=”12345”;

BigInteger c=BigInteger.valueOf(s);

则c=12345；


2.add(); 大整数相加

BigInteger a=new BigInteger(“23”);

BigInteger b=new BigInteger(“34”);

a. add(b);


3.subtract(); 相减

4.multiply(); 相乘

5.divide(); 相除取整

6.remainder(); 取余

7.pow(); a.pow(b)=a^b

8.gcd(); 最大公约数

9.abs(); 绝对值

10.negate(); 取反数

11.mod(); a.mod(b)=a%b=a.remainder(b);

12.max(); min();

13.punlic int comareTo();

14.boolean equals(); 是否相等

15.BigInteger构造函数：
```



**加法**

> 注意进位
>
> 使用动态数组Vector,其功能与StringBuffer类似



```java
package 高精度;

import java.util.Scanner;
import java.util.Vector;

public class 加法 {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String A, B;
        Vector<Integer> a = new Vector<>();
        Vector<Integer> b = new Vector<>();
        A = sc.next();
        B = sc.next();
        for (int i = A.length() - 1; i >= 0; i--) a.add(A.charAt(i) - '0');
        for (int i = B.length() - 1; i >= 0; i--) b.add(B.charAt(i) - '0');
        Vector<Integer> c = add(a, b);
        for (int i = c.size() - 1; i >= 0; i--)
            System.out.print(c.elementAt(i));//同理与get	
    }

    public static Vector<Integer> add(Vector<Integer> a, Vector<Integer> b) {
        Vector<Integer> c = new Vector<>();
        if (a.size() < b.size())//简化计算
            return add(b, a);
        int t = 0;//进位
        for (int i = 0; i < a.size(); i++) {
            if (i < a.size()) t += a.get(i);
            if (i < b.size()) t += b.get(i);
            c.add(t % 10);
            t /= 10;
        }
        return c;
    }
}
```





**减法**

> 要注意借位以及初始两数的大小



```java
package 高精度;

import java.util.Scanner;
import java.util.Vector;

public class 减法 {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String A, B;
        Vector<Integer> a = new Vector<>();
        Vector<Integer> b = new Vector<>();
        A = sc.next();
        B = sc.next();
        for (int i = A.length() - 1; i >= 0; i--) a.add(A.charAt(i) - '0');
        for (int i = B.length() - 1; i >= 0; i--) b.add(B.charAt(i) - '0');
        Vector<Integer> c;
        if (cmp(a, b)) {
            c = sub(a, b);
            for (int i = c.size() - 1; i >= 0; i--)
                System.out.print(c.get(i));
        } else {
            c = sub(b, a);
            System.out.print('-');
            for (int i = c.size() - 1; i >= 0; i--)
                System.out.print(c.get(i));
        }

    }

    public static Vector<Integer> sub(Vector<Integer> a, Vector<Integer> b) {
        Vector<Integer> c = new Vector<>();
        int t = 0;//借位
        //t=a当前值减去b当前值减去借位
        for (int i = 0; i < a.size(); i++) {
            t = a.get(i) - t;
            if (i < b.size()) t -= b.get(i);
            c.add((t + 10) % 10);//t>0时为t,小于0时为t+10
            if (t >= 0) t = 0;
            else t = 1;
        }
        while (c.size() > 0 && c.get(c.size() - 1) == 0) c.remove(c.size() - 1);//去掉前导0
        return c;
    }

    public static boolean cmp(Vector<Integer> a, Vector<Integer> b) {//判断大小
        if (a.size() != b.size()) return a.size() > b.size();
        for (int i = 0; i < a.size(); i++) {
            if (a.get(i) != b.get(i))
                return a.get(i) > b.get(i);
        }
        return true;
    }
```



**乘法**



```java
package 高精度;

import java.util.Scanner;
import java.util.Vector;

public class 乘法 {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String A, B;
        Vector<Integer> a = new Vector<>();
        Vector<Integer> b = new Vector<>();
        A = sc.next();
        B = sc.next();
        for (int i = A.length() - 1; i >= 0; i--) a.add(A.charAt(i) - '0');
        for (int i = B.length() - 1; i >= 0; i--) b.add(B.charAt(i) - '0');
        Vector<Integer> c = mul(a, b);
        for (int i = c.size() - 1; i >= 0; i--)
            System.out.print(c.get(i));
    }

    public static Vector<Integer> mul(Vector<Integer> a, Vector<Integer> b) {
        Vector<Integer> c = new Vector<Integer>();
        int t = 0;
        for (int i = 0; i < a.size(); i++) {
            t = a.get(i) * b.get(0) + t;
            c.add(t % 10);
            t /= 10;
        }
        return c;
    }
}
```





**除法**



```java
package 高精度;

import java.util.Scanner;
import java.util.Vector;


public class 除法 {
    static int r = 0;

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String A;
        Vector<Integer> a = new Vector<>();
        A = sc.next();
        int b = sc.nextInt();
        for (int i = A.length() - 1; i >= 0; i--) a.add(A.charAt(i) - '0');
        Vector<Integer> c = div(a, b);
        for (int i = 0; i < c.size(); i++)
            System.out.println(c.get(i));
        System.out.println(r);
    }

    //商是c余数是r
    public static Vector<Integer> div(Vector<Integer> a, int b) {
        Vector<Integer> c = new Vector<>();
        for (int i = a.size() - 1; i >= 0; i--) {
            r = r * 10 + a.get(i);
            c.add(r / b);
            r %= b;
        }
        while (c.size() > 0 && c.get(0) == 0) c.remove(0);
        return c;
    }
}
```







## 前缀和&差分

### 前缀和



**一维**

- 前缀和的概念：**即数组该位置之前的元素之和。**

- 还有一个重要的点，**在进行前缀和的运算时，下标从1开始，设数组a[0]=0**;

  <!--比如a[5] = {0,1,2,3,4};-->

  <!--求a[1]的前缀和：a[1];-->

  <!--求a[2]的前缀和：a[1]+a[2];-->

  <!--s[i]=s[i-1]+a[i];-->

  为什么下标要从1 开始：为了方便后面的计算，避免下标转换，设为零，不影响结果

- 数组下标L到R之间的和为S[R]-S[L-1];

- **前缀和的作用：** 快速求出元素组中某段区间的和，时间短



**二维**



**公式**：**`s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + arr[i][j]`**

<img src="../../typora/image/image-20211005171311709.png" alt="image-20211005171311709" style="zoom:80%;" />



```java
//定义s二维数组，求解前缀和s数组
int[][] s = new int[n+1][m+1];
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <=m ; j++) {
        s[i][j] = s[i-1][j]+s[i][j-1]-s[i-1][j-1]+arr[i][j];
    }
}
```



输入区间范围（**x1,y1,x2,y2）,`s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1]`**的结果就是所求区间的和；

<img src="../../typora/image/image-20211005170941982.png" alt="image-20211005170941982" style="zoom:80%;" />



```java
//求解前缀和
while(q-- !=0){
    int x1 = sc.nextInt();
    int y1 = sc.nextInt();
    int x2 = sc.nextInt();
    int y2 = sc.nextInt();
    int res = s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1];
    System.out.println(res);
}
```



[连续数组](https://leetcode-cn.com/problems/contiguous-array/)



### 差分

**一维**

- **差分的概念**：差分其实就是前缀和的逆运算
- **差分的作用**：如果对某个区间需要每个元素加上C则需要使用差分来减少时间复杂度
- 给定a[1],a[2]....a[n];构造擦划分数组b[N];使得**a[i] = b[1]+b[2]+....+b[i];    b[n] = a[n] - a[n-1]**
- **核心操作**：*将a[L~R]全部加上C，等价于：**b[L] +=C, b[R+1] -=C**;

<img src="../../typora/image/image-20211005174557966.png" alt="image-20211005174557966" style="zoom: 80%;" />



**二维**

- `a[][]`数组是`b[][]`数组的前缀和数组，那么`b[][]`是`a[][]`的差分数组

- 二维差分的核心也是构造差分数组`b[][]`,使得a数组中`a[i][j]`是b数组左上角(1,1)到右下角(i,j)所包围矩形元素的和；

  怎么让子矩阵中的每个元素加上c;

<img src="../../typora/image/image-20211006144334102.png" alt="image-20211006144334102" style="zoom:80%;" />

[相关资料](https://www.cnblogs.com/xbhog/p/14348830.html)







## 双指针



- **核心思想：**将O(n^2)优化成O(n);

- **对撞指针**是指在有序数组中，将指向最左侧的索引定义为`左指针(left)`，最右侧的定义为`右指针(right)`，然后从两头向中间进行数组遍历。

  > 对撞数组适用于**有序数组**，也就是说当你遇到题目给定有序数组时，应该第一时间想到用对撞指针解题。

- **快慢指针**也是双指针，但是两个指针从同一侧开始遍历数组，将这两个指针分别定义为`快指针（fast）`和`慢指针（slow）`，两个指针以不同的策略移动，直到两个指针的值相等（或其他特殊条件）为止，如fast每次增长两个，slow每次增长一个。







[救生艇问题](https://leetcode-cn.com/problems/boats-to-save-people/)

[删除数组中的重复项](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)

[环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)





## 区间优化



- 将多个区间进行合并

1. 按照区间左端点进行排序
2. 扫描过程中，维护当前区间，将所有可能有交集的区间进行合并



[区间合并](https://leetcode-cn.com/problems/merge-intervals/)











## 链表



### 单链表



**邻接表**：存储树或者图

> 用数组来模拟链表（静态链表）（因为动态链表会使用更多的时间）
>
> 可以两个数组来存储，一个存val，一个存next
>
> ![image-20211013191516054](../../typora/image/image-20211013191516054.png)



```Java
package 链表;

//用数组来模拟链表
public class 数组模拟 {
    private static final int N = 10010;
    private static int head;
    private static int[] val = new int[N];
    private static int[] next = new int[N];
    private static int index;

    //初始化
    public void init() {
        head = -1;
        index = 0;
    }

    //将x插到头结点
    public void add_to_head(int x) {
        val[index] = x;
        next[index] = head;
        head = index++;
    }

    //将x插到下标是k的节点后面
    public void add_to_k(int k, int x) {
        val[index] = x;
        next[index] = next[k];
        next[k] = index++;
    }

    //将下标k的下个数删除
    public void remove(int k) {
        next[k] = next[next[k]];
    }
}
```





### 双链表



> 下标为0在左边，下标为1在右边



```java
package 链表;

public class 数组模拟单链表 {
    private static final int N = 100010;
    private static int head;
    private static int[] val = new int[N];
    private static int[] L = new int[N];
    private static int[] R = new int[N];
    private static int index;

    //初始化，0为左端点，1为右端点
    public void init() {
        L[1] = 0;
        R[0] = 1;
        index = 2;
    }


    //将x插到下标是k的节点后面
    public void add_to_k(int k, int x) {
        val[index] = x;
        R[index] = R[k];
        L[index] = k;
        L[R[k]] = index;
        R[k] = index++;
    }

    //将下标k的下个数删除
    public void remove(int k) {
        R[L[k]] = R[k];
        L[R[k]] = L[k];
    }

}
```







## 栈和队列



### 栈

> **先进后出**

**单调栈**

```java
package 栈和队列;

import java.util.Scanner;

public class 单调栈 {
    private static final int N = 100010;

    public static void main(String[] args) {
        int top = 0;
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] ans = new int[N];
        for (int i = 0; i < n; i++) {
            int x = sc.nextInt();
            while (top > 0 && ans[top] >= x) top--;
            if (top > 0) System.out.print(ans[top] + " ");
            else System.out.print(-1 + " ");
            ans[++top] = x;
        }
    }
}

```





[每日温度](https://leetcode-cn.com/problems/iIQa4I)





### 队列

**单调队列**

```c++
#include <iostream>

using namespace std;
const int N = 100010;
int a[N], q[N];
int n, k;

int main() {
    scanf("%d%d", &n, &k);
    for (int i = 0; i < n; ++i) {
        scanf("%d", &a[i]);
    }
    int hh = 0, tt = -1;
    for (int i = 0; i < n; ++i) {
        if (hh <= tt && i - k + 1 > q[hh]) hh++;
        while (hh <= tt && a[q[tt]] >= a[i]) tt--;
        q[++tt] = i;
        if (i >= k - 1) printf("%d ", a[q[hh]]);
    }
    puts(" ");
    return 0;
}
```





## KMP





- **符串匹配算法，效率很高**
- O（n）

```c++
#include <iostream>

using namespace std;
const int N = 10010, M = 100010;
char a[N], q[M];
int ne[N];
int n, m;

int main() {
    cin >> m >> q + 1 >> n >> a + 1;
    //求next
    for (int i = 2, j = 0; i < n; i++) {
        while (j && a[i] != a[j + 1]) j = ne[j];
        if (a[i] == a[j + 1]) j++;
        ne[i] = j;
    }

    //KMP匹配
    for (int i = 1, j = 0; i <= m; i++) {
        while (j && q[i] != a[j + 1]) j = ne[j];
        if (q[i] == a[j + 1]) j++;
        if (j == n) {
            cout << i - n << " " << i - 1;
            j = ne[j];
        }
    }
    return 0;
}
```



[资料](https://www.cnblogs.com/zzuuoo666/p/9028287.html)









## Tire树



- 字典树
- 快速存储字符串集合的数据结构



> 求数组的最大异或

```c++
#include <iostream>

using namespace std;
const int N = 100010;
int son[N][2], cnt[N], idx;
char str[N];

void insert(int x) {
    int p = 0;
    for (int i = 31; i >= 0; i--) {
        int u = x >> i & 1;
        if (!son[p][u]) son[p][u] = ++idx;
        p = son[p][u];
    }
}

int query(int x) {
    int p = 0;
    int ret = 0;
    for (int i = 31; i >= 0; i--) {
        int u = x >> i & 1;
        if (!son[p][!u]) {
            p = son[p][u];
            ret = ret * 2 + u;
        } else {
            p = son[p][!u];
            ret = ret * 2 + !u;
        }
    }
    return ret ^ x;
}

int main() {
    int n;
    cin >> n;
    int maxN = 0;
    while (n--) {
        int x;
        cin >> x;
        insert(x);
        maxN = max(query(x), maxN);
    }
    cout << maxN << endl;
    return 0;
}
```





[力扣](https://leetcode-cn.com/problems/design-add-and-search-words-data-structure/)





## 并查集



- 将两个集合合并
- 询问两个元素是否在一个集合中

**基本原理：每个集合用一颗树来表示，每一颗树的编号就是每一个集合的编号，每个节点存它的父节点，p[x]表示x的父节点。**

1. 如何判断树根：if(p[x]==x)
2. 如何求x的集合编号：while(p[x]!=x) x=p[x];
3. 如何合并两个集合：p[x]=y;

> 开始时每个数的父亲节点是它自己，只有将集合合并父亲节点才会改变。
>
> 

```c++
#include <iostream>

using namespace std;
const int N = 100010;
int p[N];
int n, m;

int find(int x) {
    if (x != p[x]) p[x] = find(p[x]);
    return p[x];
}

int main() {
    cin >> n >> m;
    for (int i = 1; i < n; i++) {
        p[i] = i;
    }
    while (m--) {
        int a, b;
        char op;
        cin >> op >> a >> b;
        if (op == 'M') {
            p[find(a)] = find(b);
        } else {
            if (find(a) == find(b)) {
                cout << "Yes" << endl;
            } else {
                cout << "No" << endl;
            }
        }
    }
    return 0;
}
```





## 堆

**完全二叉树**

1. 插入一个数     heap[++size]=x;up(size);
2. 求集合中的最小值:    heap[1]
3. 删除集合中的最小值,用最后一个元素替换顶元素，再down。heap[1]=heap[size],size--,down(1)
4. 删除任意元素  heap[k]=heap[size],size--,down(k),up(k);
5. 

- 可用一维数组存储
- x的左儿子是2x，右儿子为2x+1



> 输出前m个最小的数
>
> 先构建堆，每次输出堆顶元素后删除，然后维护。

```C++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 100010;
int n, m;
int heap[N], size;

void down(int x) {
    int t = x;
    if (2 * x <= size && heap[2 * x] < heap[t]) t = 2 * x;
    if (2 * x + 1 <= size && heap[2 * x + 1] < heap[t]) t = 2 * x + 1;
    if (t != x) {
        swap(heap[t], heap[x]);
        down(t);
    }
}

void up(int x) {
    while (x / 2 && heap[x / 2] > heap[x]) {
        swap(heap[x / 2], heap[x]);
        x /= 2;
    }
}

int main() {
    ios::sync_with_stdio(false);

    cin >> n >> m;
    for (int i = 1; i <= n; i++) {
        cin >> heap[i];
    }
    size = n;
    for (int i = n / 2; i; i--) down(i);//小于O(n)
    while (m--) {
        cout << heap[1] << " ";
        heap[1] = heap[size];
        size--;
        down(1);
    }
    return 0;
}


```

```c++
#include <iostream>
#include <algorithm>
#include <string>
#include <cstring>

using namespace std;

const int N = 100010;
int n, m;
int heap[N], ph[N], hp[N], size;

void heap_swap(int a, int b) {
    swap(ph[hp[a]], ph[hp[b]]);
    swap(hp[a], hp[b]);
    swap(heap[a], heap[b]);
}

void down(int x) {
    int t = x;
    if (2 * x <= size && heap[2 * x] < heap[t]) t = 2 * x;
    if (2 * x + 1 <= size && heap[2 * x + 1] < heap[t]) t = 2 * x + 1;
    if (t != x) {
        swap(heap[t], heap[x]);
        down(t);
    }
}

void up(int x) {
    while (x / 2 && heap[x / 2] > heap[x]) {
        swap(heap[x / 2], heap[x]);
        x /= 2;
    }
}

int main() {
    ios::sync_with_stdio(false);
    m = 0;
    cin >> n;
    while (n--) {
        char op[10];
        int k, x;
        cin >> op;
        if (!strcmp(op, "I")) {
            cin >> x;
            size++;
            m++;
            ph[m] = size;
            hp[size] = m;
            heap[size] = x;
            up(size);
        }
        else if (!strcmp(op, "PM")) cout << heap[1] << endl;//输出最小
        else if (!strcmp(op, "DM")) {//删除最小
            heap_swap(size, 1);
            size--;
            down(1);
        } else if (!strcmp(op, "D")) {//删除第k个元素
            cin >> k;
            k = ph[k];
            heap_swap(k, size);
            size--;
            down(k), up(k);
        } else if (!strcmp(op, "C")) { //修改第k个数的值
            cin >> k >> x;
            k = ph[k];
            heap[k] = x;
            down(k);
            up(k);
        }
    }
    return 0;
}
```







## 哈希表

- 存储结构：拉链法，开放寻址法

- 字符串哈希方式

**拉链法**

> 将较大的数映射成较小的数
>
> 模数尽量取质数并且离二的整次幂较远

![image-20211024225052753](F:\typora\image\image-20211024225052753.png)

```C++
#include <iostream>
#include <algorithm>
#include <string>
#include <cstring>

using namespace std;

const int N = 100003;
int h[N];//映射的表
int e[N], ne[N], idx;//链表

void insert(int x) {
    int k = (x % N + N) % N;//将负数转换成正数
    e[idx] = x;
    ne[idx] = h[k];
    h[k] = idx++;
}

bool find(int x) {
    int k = (x % N + N) % N;//将负数转换成正数
    for (int i = h[k]; i != -1; i = ne[i]) {
        if (e[i] == x) {
            return true;
        }
    }
    return false;
}

int main() {
    memset(h, -1, sizeof h);//将h初始值全设为-1；
    int n;
    cin >> n;
    while (n--) {
        char op;
        int x;
        cin >> op >> x;
        if (op == 'I') {
            insert(x);
        } else {
            if (find(x)) puts("Yes");
            else puts("No");
        }
    }
    return 0;
}
```





**开放寻址法**

> 将数组范围开到题目给的两到三倍（防止位满死循环）
>
> find函数返回x所在的位置或者应该存储的位置



```C++
#include <iostream>
#include <algorithm>
#include <string>
#include <cstring>
using namespace std;

const int N = 200003;
int h[N], null = 0x3f3f3f3f;

int find(int x) {
    int k = (x % N + N) % N;//将负数转换成正数
    while (h[k] != null && h[k] != x) {
        k++;
        if (k == N) k = 0;
    }
    return k;
}

int main() {
    memset(h, 0x3f, sizeof h);//将h初始值全设为0x3f3f3f3f；
    int n;
    cin >> n;
    while (n--) {
        char op;
        int x;
        cin >> op >> x;
        int k = find(x);
        if (op == 'I') {
            h[k] = x;
        } else {
            if (h[k] != null) puts("Yes");
            else puts("No");
        }
    }
    return 0;
}
```





**字符串哈希方式**



> Q可用longlong表示

<img src="../../typora/image/image-20211025214753527.png" alt="image-20211025214753527" style="zoom: 50%;" />





![image-20211025215307780](../../typora/image/image-20211025215307780.png)





[字符串哈希](https://www.luogu.com.cn/problem/P3370)







## 常用的数据结构



#### **Vector**

- Vector 是同步访问的。

- Vector 包含了许多传统的方法，这些方法不属于集合框架。

- Vector 主要用在事先不知道数组的大小，或者只是需要一个可以改变大小的数组的情况。

  

  Vector 类支持 4 种构造方法。

```java
Vector();//第一种构造方法创建一个默认的向量，默认大小为 10：
```

```java
Vector(int size)//第二种构造方法创建指定大小的向量。
```

```java
Vector(int size,int incr)//第三种构造方法创建指定大小的向量，并且增量用 incr 指定。增量表示向量每次增加的元素数目。
```

```java
Vector(Collection c)//第四种构造方法创建一个包含集合 c 元素的向量.
```





#### Pair

- Map 对象是 key,value  可以多对
- Pair对象是  object,object  只能一对

```java
Pair<Integer, String> pair = new Pair<>(1, "One");
Integer key = pair.getKey();
String value = pair.getValue();
```





#### Queue

- 队列是一种特殊的线性表，它只允许在表的前端进行删除操作，而在表的后端进行插入操作。

- LinkedList类实现了Queue接口，因此我们可以把LinkedList当成Queue来用。



```java
import java.util.LinkedList;
import java.util.Queue;
 
public class Main {
    public static void main(String[] args) {
        //add()和remove()方法在失败的时候会抛出异常(不推荐)
        Queue<String> queue = new LinkedList<String>();
        //添加元素
        queue.offer("a");
        queue.offer("b");
        queue.offer("c");
        queue.offer("d");
        queue.offer("e");
        for(String q : queue){
            System.out.println(q);
        }
        System.out.println("===");
        System.out.println("poll="+queue.poll()); //返回第一个元素，并在队列中删除
        for(String q : queue){
            System.out.println(q);
        }
        System.out.println("===");
        System.out.println("element="+queue.element()); //返回第一个元素 
        for(String q : queue){
            System.out.println(q);
        }
        System.out.println("===");
        System.out.println("peek="+queue.peek()); //返回第一个元素 
        for(String q : queue){
            System.out.println(q);
        }
    }
}
```





#### Stack

| **1** | **boolean empty()  测试堆栈是否为空。**                      |
| ----- | ------------------------------------------------------------ |
| **2** | **Object peek( ) 查看堆栈顶部的对象，但不从堆栈中移除它。**  |
| **3** | **Object pop( ) 移除堆栈顶部的对象，并作为此函数的值返回该对象。** |
| **4** | **Object push(Object element) 把项压入堆栈顶部。**           |
| **5** | **int search(Object element) 返回对象在堆栈中的位置，以 1 为基数。** |





#### PriorityQueue（优先队列）



- PriorityQueue是一个无限制的队列，并且动态增长。默认初始容量`'11'`可以使用相应构造函数中的**initialCapacity**参数覆盖。
- 它不允许NULL对象。
- 添加到PriorityQueue的对象必须具有可比性。
- 默认情况下，优先级队列的对象**按自然顺序排序**。
- 比较器可用于队列中对象的自定义排序。
- 优先级队列的**头部**是基于自然排序或基于比较器的排序的**最小**元素。当我们轮询队列时，它从队列中返回头对象。
- 如果存在多个具有相同优先级的对象，则它可以随机轮询其中任何一个。
- PriorityQueue **不是线程安全的**。`PriorityBlockingQueue`在并发环境中使用。
- 它为add和poll方法提供了**O（log（n））**时间。



**Java PriorityQueue构造函数**

| **PriorityQueue（）**：使用默认初始容量（11）构造空队列，该容量根据其自然顺序对其元素进行排序。 |
| ------------------------------------------------------------ |
| **PriorityQueue（Collection c）**：构造包含指定集合中元素的空队列。 |
| **PriorityQueue（int initialCapacity）**：构造具有指定初始容量的空队列，该容量根据其自然顺序对其元素进行排序。 |
| **PriorityQueue（int initialCapacity，Comparator comparator）**：构造具有指定初始容量的空队列，该容量根据指定的比较器对其元素进行排序。 |
| **PriorityQueue（PriorityQueue c）**：构造包含指定优先级队列中元素的空队列。 |
| **PriorityQueue（SortedSet c）**：构造包含指定有序集合中元素的空队列。 |



 **Java PriorityQueue方法**



- **boolean add（object）**：将指定的元素插入此优先级队列。
- **boolean offer（object）**：将指定的元素插入此优先级队列。
- **boolean remove（object）**：从此队列中删除指定元素的单个实例（如果存在）。
- **Object poll（）**：检索并删除此队列的头部，如果此队列为空，则返回null。
- **Object element（）**：检索但不删除此队列的头部，如果此队列为空，则返回null。
- **Object peek（）**：检索但不删除此队列的头部，如果此队列为空，则返回null。
- **void clear（）**：从此优先级队列中删除所有元素。
- **Comparator comparator（）**：返回用于对此队列中的元素进行排序的比较器，如果此队列根据其元素的自然顺序排序，则返回null。
- **boolean contains（Object o）**：如果此队列包含指定的元素，则返回true。
- **Iterator iterator（）**：返回此队列中元素的迭代器。
- **int size（）**：返回此队列中的元素数。
- **Object [] toArray（）**：返回包含此队列中所有元素的数组。



#### 双端队列（Deque）



- 双端队列是指允许两端都可以进行入队和出队操作的队列，其元素的逻辑结构仍是线性结构。

- 将队列的两端分别称为前端和后端，两端都可以入队和出队。
- Deque继承自Queue接口，Deque的实现类是LinkedList、ArrayDeque、LinkedBlockingDeque，其中LinkedList是最常用的。



| **Queue方法** | **等效Deque方法** |
| ------------- | ----------------- |
| add(e)        | addLast(e)        |
| offer(e)      | offerLast(e)      |
| remove()      | removeFirst()     |
| poll()        | pollFirst()       |
| element()     | getFirst()        |
| peek()        | peekFirst()       |

| **堆栈方法** | **等效Deque方法** |
| ------------ | ----------------- |
| push(e)      | addFirst(e)       |
| pop()        | removeFirst()     |
| peek()       | peekFirst()       |







### Collection相关方法



![image-20211030190655199](../../typora/image/image-20211030190655199.png)





这些方法属于Collection类，可以被子类继承，因此通用性较强，不仅List能用，Set也能用。

| 返回类型 | 方法名称           | 描述                 |
| -------- | ------------------ | -------------------- |
| boolean  | add(Object o)      | 添加元素             |
| int      | size()             | 获取元素个数         |
| boolean  | contains(Object o) | 判断是否存在指定元素 |
| boolean  | remove(Object o)   | 删除元素             |
| void     | clear()            | 清空                 |
| boolean  | isEmpty()          | 判空                 |
| Object[] | toArray()          | 集合转数组           |
| all      | reverse()          | 反转                 |



#### List



**List相关方法**

List的派生类对象可以使用，Set不可用。
都是和索引相关的方法：

| 返回类型 | 方法名称                  | 描述                                 |
| -------- | ------------------------- | ------------------------------------ |
| void     | add(int index, E element) | 指定位置添加元素                     |
| int      | indexOf(Object o)         | 获取指定元素的索引                   |
| E        | set(int index, E element) | 替换指定位置的元素，返回更新前的元素 |
| E        | get(int index)            | 获取指定索引的元素                   |
| E        | remove(int index)         | 删除指定索引的元素                   |

```tsx
A:添加功能
boolean add(E e):向集合中添加一个元素
void add(int index, E element):在指定位置添加元素
boolean addAll(Collection<? extends E> c)：向集合中添加一个集合的元素。
    
B:删除功能
void clear()：删除集合中的所有元素
E remove(int index)：根据指定索引删除元素，并把删除的元素返回
boolean remove(Object o)：从集合中删除指定的元素
boolean removeAll(Collection<?> c):从集合中删除一个指定的集合元素。

C:修改功能
E set(int index, E element):把指定索引位置的元素修改为指定的值，返回修改前的值。

D:获取功能
E get(int index)：获取指定位置的元素
Iterator iterator():就是用来获取集合中每一个元素。

E:判断功能
boolean isEmpty()：判断集合是否为空。
boolean contains(Object o)：判断集合中是否存在指定的元素。
boolean containsAll(Collection<?> c)：判断集合中是否存在指定的一个集合中的元素。

F:长度功能
int size():获取集合中的元素个数

G:把集合转换成数组
Object[] toArray():把集合变成数组。
```





- ArrayList使用数组实现，查询快，增删慢；
- LinkedList使用链表实现，查询慢，增删快，适用于经常插入、删除大量数据的场合，适合采用迭代器Iterator遍历。
- 如果仅仅是在列表末尾插入数据，LinkedList的效率低于ArrayList，因为LinkedList调用add时需要创建对象，而ArrayList只是在容量不够时才扩容。





#### Set



**HashSet**

> HashSet实现Set接口，底层由HashMap(后面讲解)来实现，为哈希表结构，新增元素相当于HashMap的key，value默认为一个固定的Object。在我看来，HashSet相当于一个阉割版的HashMap;
>
> 当有元素插入的时候，会计算元素的hashCode值，将元素插入到哈希表对应的位置中来；
>
> 它继承于AbstractSet，实现了Set, Cloneable, Serializable接口。
>
> (1)HashSet继承AbstractSet类，获得了Set接口大部分的实现，减少了实现此接口所需的工作，实际上是又继承了AbstractCollection类；
>
> (2)HashSet实现了Set接口，获取Set接口的方法，可以自定义具体实现，也可以继承AbstractSet类中的实现；
>
> (3)HashSet实现Cloneable，得到了clone()方法，可以实现克隆功能；
>
> (4)HashSet实现Serializable，表示可以被序列化，通过序列化去传输，典型的应用就是hessian协议。

具有如下特点：

- 不允许出现重复因素；
- 允许插入Null值；
- 元素无序（添加顺序和遍历顺序不一致）；
- 线程不安全，若2个线程同时操作HashSet，必须通过代码实现同步；



**TreeSet**

> 从名字上可以看出，此集合的实现和树结构有关。与HashSet集合类似，TreeSet也是基于Map来实现，具体实现**TreeMap**，其底层结构为**红黑树**（特殊的二叉查找树）；
>
> 与HashSet不同的是，TreeSet具有排序功能，分为自然排序(123456)和自定义排序两类，默认是自然排序；在程序中，我们可以按照任意顺序将元素插入到集合中，等到遍历时TreeSet会按照一定顺序输出--倒序或者升序；
>
> 它继承AbstractSet，实现NavigableSet, Cloneable, Serializable接口。
>
> （1）与HashSet同理，TreeSet继承AbstractSet类，获得了Set集合基础实现操作；
>
> （2）TreeSet实现NavigableSet接口，而NavigableSet又扩展了SortedSet接口。这两个接口主要定义了搜索元素的能力，例如给定某个元素，查找该集合中比给定元素大于、小于、等于的元素集合，或者比给定元素大于、小于、等于的元素个数；简单地说，实现NavigableSet接口使得TreeSet具备了元素搜索功能；
>
> （3）TreeSet实现Cloneable接口，意味着它也可以被克隆；
>
> （4）TreeSet实现了Serializable接口，可以被序列化，可以使用hessian协议来传输；

具有如下特点：

- 对插入的元素进行排序，是一个有序的集合（主要与HashSet的区别）;
- 底层使用红黑树结构，而不是哈希表结构；
- 允许插入Null值；
- 不允许插入重复元素；
- 线程不安全；

[https://blog.csdn.net/zhanshixiang/article/details/82492872]()

https://www.cnblogs.com/ttqi/p/10948737.html







#### Map



- **HashMap**

> 最常用的Map,它根据键的HashCode 值存储数据,根据键可以直接获取它的值，具有很快的访问速度。HashMap最多只允许一条记录的键为Null(多条会覆盖);允许多条记录的值为 Null。非同步的。

- **TreeMap**

> 能够把它保存的记录根据键(key)排序,默认是按升序排序，也可以指定排序的比较器，当用Iterator 遍历TreeMap时，得到的记录是排过序的。TreeMap不允许key的值为null。非同步的。 
>
> [TreeMap完全解析](https://www.jianshu.com/p/2dcff3634326)

- **Hashtable**

> 与 HashMap类似,不同的是:key和value的值均不允许为null;它支持线程的同步，即任一时刻只有一个线程能写Hashtable,因此也导致了Hashtale在写入时会比较慢。 

- **LinkedHashMap**

> 保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的.在遍历的时候会比HashMap慢。key和value均允许为空，非同步的。 





**Map的遍历**



**增强for循环遍历**

- **使用keySet()遍历**

  ```java
  for (String key : map.keySet()) {
      System.out.println(key + " ：" + map.get(key));
  }
  ```

  

- **使用entrySet()遍历**

```java
for(Map.Entry<String, String> entry : map.entrySet()) {
  System.out.println(entry.getKey() + " ："+ entry.getValue());
}
```



**迭代器遍历**

- **使用keySet()遍历**

```java
Iterator<String> iterator = map.keySet().iterator();
while(iterator.hasNext()) {
  String key = iterator.next();
  System.out.println(key + "　："+ map.get(key));
}
```



- **使用entrySet()遍历**

```java
Iterator<Map.Entry<String, String>> iterator = map.entrySet().iterator();
while(iterator.hasNext()) {
  Map.Entry<String, String> entry = iterator.next();
  System.out.println(entry.getKey() + "　："+ entry.getValue());
}
```











## 搜索与图论





### DFS

> 数据结构：stack
>
> 空间：O(h)
>
> 不具有最短路的性质

- 回溯
- 减枝



**用DFS输出全排列**

```Java
import java.util.Scanner;

public class DFS {
    public static int[] path;
    public static int n;
    public static boolean[] flag;

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        n = scanner.nextInt();
        path = new int[n + 1];
        flag = new boolean[n + 1];
        dfs(0);
    }

    public static void dfs(int u) {
        if (u == n) {
            for (int i = 0; i < n; i++) {
                System.out.print(path[i] + " ");
            }
            System.out.println();
            return;
        }
        for (int i = 1; i <= n; i++) {
            if (!flag[i]) {
                path[u] = i;
                flag[i] = true;
                dfs(u + 1);
                flag[i] = false;
            }
        }
    }
}
```



**[n皇后问题](https://www.acwing.com/problem/content/845/)**

**[Leecode  n皇后](https://leetcode-cn.com/problems/n-queens/)**

第一种方法和第二种方法比较（1<=n<=9）

![image-20211115225159979](../../typora/image/image-20211115225159979.png)

```java
import java.util.Scanner;

//n皇后问题
public class n_q {
    public static final int N = 1000;
    public static int n;//棋盘大小
    public static char[][] g = new char[N][N];//棋盘；
    public static boolean[] row = new boolean[N];//行
    public static boolean[] col = new boolean[N];//列
    public static boolean[] dg = new boolean[N];//正对角线
    public static boolean[] udg = new boolean[N];//反对角线

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        n = scanner.nextInt();
        for (int i = 0; i < n; i++)
            for (int j = 0; j < n; j++) {
                g[i][j] = '.';
            }
        System.out.println(1);
        dfs1(0);
        System.out.println(2);
        dfs2(0, 0, 0);
    }

    public static void dfs1(int u) {//时间O(n*n!)(最坏)
        if (u == n) {
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    System.out.print(g[i][j]);
                }
                System.out.println();
            }
            System.out.println();
            return;
        }
        for (int i = 0; i < n; i++) {
            if (!col[i] && !dg[u + i] && !udg[i - u + n]) {
                g[u][i] = 'Q';
                col[i] = dg[u + i] = udg[i - u + n] = true;
                dfs1(u + 1);
                col[i] = dg[u + i] = udg[i - u + n] = false;
                g[u][i] = '.';
            }
        }
    }

    public static void dfs2(int x, int y, int s) {//时间O(2^n^20)
        if (y == n) {
            y = 0;
            x++;
        }
        if (x == n) {
            if (s == n) {
                for (int i = 0; i < n; i++) {
                    for (int j = 0; j < n; j++) {
                        System.out.print(g[i][j]);
                    }
                    System.out.println();
                }
                System.out.println();
            }
            return;
        }

        //放
        if (!row[x] && !col[y] && !dg[x + y] && !udg[y - x + n]) {
            g[x][y] = 'Q';
            row[x] = col[y] = dg[x + y] = udg[y - x + n] = true;
            dfs2(x, y + 1, s + 1);
            row[x] = col[y] = dg[x + y] = udg[y - x + n] = false;
            g[x][y] = '.';
        }
        //不放
        dfs2(x, y + 1, s);
    }
}
```







### BFS

> 数据结构：queue
>
> 空间：O(2^h)
>
> 具有最短路的性质
>
> 所有边权都一样





[八数码](https://www.acwing.com/problem/content/description/847/)

```java
package 树与图;

import java.util.*;

public class eightDigital {
    public static Queue<String> q = new ArrayDeque<>();
    public static Map<String, Integer> ans = new HashMap<>();
    public static int[] dx = {-1, 0, 1, 0}, dy = {0, 1, 0, -1};
    public static String s;
    public static int n = 9;

    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        String start = "";
        for (int i = 1; i <= 9; i++) {
            String ch = scan.next();
            start += ch;
        }
        ans.put(start, 0);
        q.offer(start);
        System.out.println(bfs());
    }

    public static int bfs() {
        while (!q.isEmpty()) {
            s = q.poll();
            if (s.equals("12345678x"))
                return ans.get(s);
            int a = s.indexOf('x');
            int x = a / 3, y = a % 3;
            for (int i = 0; i < 4; i++) {
                int xx = x + dx[i], yy = y + dy[i];
                if (xx < 0 || xx >= 3 || yy < 0 || yy >= 3)
                    continue;
                int l = xx * 3 + yy;
                StringBuilder sb = new StringBuilder();
                for (int j = 0; j < 9; j++) {
                    if (j == l) sb.append('x');
                    else if (j == a) sb.append(s.charAt(l));
                    else sb.append(s.charAt(j));
                }
                if (!ans.containsKey(sb.toString())) {
                    ans.put(sb.toString(), ans.get(s) + 1);
                    q.offer(sb.toString());
                }
            }
        }
        return -1;
    }
}
```



> 从1到n最短距离
>

```java
package 树与图;

import java.util.Arrays;
import java.util.Scanner;

public class from1toN_BFS {
    public static final int N = 10010;
    public static int[] e = new int[N];//存储数据
    public static int[] ne = new int[N];//存储下一个点的坐标
    public static int[] h = new int[N];//头结点
    public static int idx = 0;
    public static int[] q = new int[N];//队列
    public static int[] d = new int[N];//判断是否搜过且存放距离

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int m = sc.nextInt();
        Arrays.fill(h, -1);
        for (int i = 0; i < m; i++) {
            int a = sc.nextInt();
            int b = sc.nextInt();
            add(a, b);
        }
        System.out.println(bfs(n));
    }

    public static void add(int a, int b) {//将a指向b
        e[idx] = b;
        ne[idx] = h[a];//从头部插入
        h[a] = idx++;
    }

    public static int bfs(int n) {
        int hh = 0;
        int tt = 0;
        q[0] = 1;
        Arrays.fill(d, -1);
        d[1] = 0;
        while (hh <= tt) {//队列不为空
            int t = q[hh++];
            for (int i = h[t]; i != -1; i = ne[i]) {
                int j = e[i];
                if (d[j] == -1) {
                    d[j] = d[t] + 1;
                    q[++tt] = j;
                }
            }
        }
        return d[n];
    }
}
```







### 拓扑序列

在一个有向图中，对所有的节点进行排序，要求没有一个节点指向它前面的节点。

先统计所有节点的入度，对于入度为0的节点就可以分离出来，然后把这个节点指向的节点的入度减一。

> 有向图

- 将入度为0的点加入队列
- 对头为t
- 枚举t的所有出边t->j
- 删掉t->j    d[j]--
- if(d[j]==0)  j入列

```java
package 树与图;

import java.util.Arrays;
import java.util.Scanner;

public class isTopology {
    public static final int N = 10010;
    public static int[] e = new int[N];//存储数据
    public static int[] ne = new int[N];//存储下一个点的坐标
    public static int[] h = new int[N];//头结点
    public static int idx = 0;
    public static int[] q = new int[N];//队列
    public static int[] d = new int[N];//入度

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int m = sc.nextInt();
        Arrays.fill(h, -1);
        for (int i = 0; i < m; i++) {
            int a = sc.nextInt();
            int b = sc.nextInt();
            add(a, b);
            d[b]++;//入度+1
        }
        System.out.println(topsort(n));
    }

    public static void add(int a, int b) {//将a指向b
        e[idx] = b;
        ne[idx] = h[a];//从头部插入
        h[a] = idx++;
    }

    public static boolean topsort(int n) {
        int hh = 0, tt = 0;
        for (int i = 1; i <= n; i++) {
            if (d[i] != 0) {
                q[++tt] = i;
            }
        }
        while (hh <= tt) {
            int t = q[hh++];
            for (int i = h[t]; i != -1; i = ne[i]) {
                int j = e[i];
                d[j]--;
                if (d[j] == 0) q[++tt] = j;
            }
        }
        return tt == n - 1;
    }
}
```



**（稠密图用邻接矩阵存，稀疏图用邻接表)**

**一个图中，顶点数 n  边数 m**

**当n^2>>m 时，我们称之为稀疏。**

**当m相对较大时，我们称之为稠密。**

​		



### 最短路问题

<img src="F:\typora\image\image-20211109143004633.png" alt="image-20211109143004633" style="zoom: 67%;" />

**单源最短路**：求一个点到其他点的最短路问题

1. 所有边权都是正数
   1. 朴素Dijkstra算法 O(n^2)
   2. 堆优化版Dijkstra算法 O(mlogn)
2. 存在负权边
   1. Bellman-Ford  O(mn)
   2. SPFA   一般O(m)  ，最坏O(mn)



**多源汇最短路**

Floyd   O(n^3)



#### **朴素Dijkstra算法**

> 1. dis[1]=0,dis[i]=maxvalue,s:当前已确定最短距离的点
> 2. for i=0 to n
> 3. t不在s中的距离最近的点
> 4. 将t放入s中
> 5. 用t更新其他点的距离



[Dijkstra](https://www.acwing.com/problem/content/851/)

```java
package 树与图;

import java.util.Arrays;
import java.util.Scanner;

/*
给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环，所有边权均为正值。

请你求出 1 号点到 n 号点的最短距离，如果无法从 1 号点走到 n 号点，则输出 −1。

输入格式
第一行包含整数 n 和 m。

接下来 m 行每行包含三个整数 x,y,z，表示存在一条从点 x 到点 y 的有向边，边长为 z。

输出格式
输出一个整数，表示 1 号点到 n 号点的最短距离。

如果路径不存在，则输出 −1。

数据范围
1≤n≤500,
1≤m≤105,
图中涉及边长均不超过10000。
*/
public class Dijkstra {
    public static final int maxNum = 0x3f3f3f3f;
    public static int n, m;
    public static int[] dist;//距离
    public static int[][] g;//邻接矩阵
    public static boolean[] st;

    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        n = input.nextInt();
        m = input.nextInt();
        dist = new int[n + 1];
        g = new int[n + 1][n + 1];
        st = new boolean[n + 1];

        for (int i = 1; i <= n; i++) {
            Arrays.fill(g[i], maxNum);
        }
        while (m != 0) {
            m--;
            int a = input.nextInt();
            int b = input.nextInt();
            int c = input.nextInt();
            g[a][b] = Math.min(g[a][b], c);//建立矩阵，并减去多重边
            // System.out.println(g[a][b]);
        }
        int ans = dijkstra();
        System.out.println(ans);
    }

    public static int dijkstra() {
        Arrays.fill(dist, maxNum);
        dist[1] = 0;
        for (int i = 1; i <= n; i++) {
            int t = -1;
            //i到t找到距离最小的点
            for (int j = 1; j <= n; j++) {
                if (!st[j] && (t == -1 || dist[t] > dist[j])) {
                    t = j;
                }
            }
            if (t == n)
                break;
            st[t] = true;
            for (int j = 1; j <= n; j++) {
                dist[j] = Math.min(dist[j], dist[t] + g[t][j]);
                //  System.out.println(dist[j]);
            }
        }
        return dist[n] == 10001 ? -1 : dist[n];
    }
}
```







#### Bellman-Ford

- 时间 O(nm)
- 每次要遍历所有节点

[有边数限制的最短路](acwing.com/problem/content/855/)

```java
package 树与图;

/*
给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环， 边权可能为负数。

请你求出从 1 号点到 n 号点的最多经过 k 条边的最短距离，如果无法从 1 号点走到 n 号点，输出 impossible。

注意：图中可能 存在负权回路 。

输入格式
第一行包含三个整数 n,m,k。

接下来 m 行，每行包含三个整数 x,y,z，表示存在一条从点 x 到点 y 的有向边，边长为 z。

输出格式
输出一个整数，表示从 1 号点到 n 号点的最多经过 k 条边的最短距离。

如果不存在满足条件的路径，则输出 impossible。
 */
import java.sql.Struct;
import java.util.Arrays;
import java.util.Scanner;

class Edge {
    int a, b, w;
}

public class Bellman_Ford {
    public static int N = 510, M = 10010;
    public static int n, m, k;
    public static int[] dist = new int[N];
    public static int[] backup = new int[N];//上一次操作的dist，防止路径串联
    public static Edge[] edges;
    public static final int maxNum = 0x3f3f3f3f;

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        n = in.nextInt();
        m = in.nextInt();
        k = in.nextInt();
        edges = new Edge[m];
        for (int i = 0; i < m; i++) {
            edges[i] = new Edge();
            edges[i].a = in.nextInt();
            edges[i].b = in.nextInt();
            edges[i].w = in.nextInt();
        }
        int res = bellman_ford();
        if (res == maxNum / 2)
            System.out.println("impossible");
        else
            System.out.println(res);
    }

    public static int bellman_ford() {
        Arrays.fill(dist, maxNum);
        dist[1] = 0;
        for (int i = 0; i < k; i++) {
            backup = dist.clone();
            for (int j = 0; j < m; j++) {
                int a = edges[j].a, b = edges[j].b, w = edges[j].w;
                dist[b] = Math.min(dist[b], backup[a] + w);
            }
        }
        if (dist[n] > maxNum / 2) return maxNum / 2;
        return dist[n];
    }
}
```





#### SPFA

- Bellman-Ford的一种优化
- BFS
- 每次dist[b] 变小才更新相关点

```java
package 树与图;

import java.util.Arrays;
import java.util.LinkedList;
import java.util.Queue;
import java.util.Scanner;

public class SPFA {
    public static final int N = 10010;
    public static final int maxNum = 0x3f3f3f3f;
    public static int n, m;
    public static int[] dist = new int[N];//距离
    public static boolean[] st = new boolean[N];
    public static int[] h, ne, e, w;
    public static int idx = 0;

    public static void main(String[] args) {
        h = new int[N];
        ne = new int[N];
        e = new int[N];
        w = new int[N];
        Scanner in = new Scanner(System.in);
        n = in.nextInt();
        m = in.nextInt();
        Arrays.fill(h, -1);
        for (int i = 0; i < m; i++) {
            int a = in.nextInt();
            int b = in.nextInt();
            int c = in.nextInt();
            add(a, b, c);
        }
        int res = spfa();
        if (res == -1)
            System.out.println("s");
        elseb
            System.out.println("b");
    }

    public static void add(int a, int b, int c) {
        e[idx] = b;
        w[idx] = c;
        ne[idx] = h[a];
        h[a] = idx++;
    }

    public static int spfa() {
        Arrays.fill(dist, maxNum);
        dist[1] = 0;
        Queue<Integer> queue = new LinkedList<Integer>();
        queue.add(1);
        st[1] = true;
        while (queue.size() > 0) {
            int t = queue.poll();
            st[t] = false;
            for (int i = h[t]; i != -1; i = ne[i]) {
                int j = e[i];
                if (dist[j] > dist[t] + w[i]) {
                    dist[j] = dist[t] + w[i];
                    if (!st[j]) {
                        queue.add(j);
                        st[j] = true;
                    }
                }
            }
        }
        if (dist[n] == maxNum)
            return -1;
        return dist[n];
    }
}
```







#### Floyd

![image-20211110220608387](../../typora/image/image-20211110220608387.png)



```java
package 树与图;

import java.util.Scanner;

public class Floyd {
    public static final int N = 210;
    public static final int maxNum = 0x3f3f3f3f;
    public static int n, m, Q;
    public static int[][] d = new int[N][N];

    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        n = input.nextInt();
        m = input.nextInt();
        Q = input.nextInt();
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++) {
                if (i == j) d[i][j] = 0;
                else d[i][j] = maxNum;
            }
        }
        while (m-- > 0) {
            int a = input.nextInt();
            int b = input.nextInt();
            int w = input.nextInt();
            d[a][b] = Math.min(d[a][b], w);
        }
        floyd();
        while (Q-- > 0) {
            int x = input.nextInt();
            int y = input.nextInt();
            if (d[x][y] > maxNum / 2)
                System.out.println("impossible");
            else
                System.out.println(d[x][y]);
        }
    }

    public static void floyd() {
        for (int k = 1; k <= n; k++) {//k为中转点
            for (int i = 1; i <= n; i++) {
                for (int j = 1; j <= n; j++) {
                    d[i][j] = Math.min(d[i][j], d[i][k] + d[k][j]);
                }
            }
        }
    }
}
```



**总**

[从k到所有点的最小距离](https://leetcode-cn.com/problems/network-delay-time/solution/gong-shui-san-xie-yi-ti-wu-jie-wu-chong-oghpz/)

```java
package 树与图;

import java.util.*;

public class LC743_最短路 {
    int N = 110, M = 6010;
    int n, k;

    int[][] w = new int[N][N];//邻接矩阵

    int[] he = new int[N];//邻接表
    int[] e = new int[M];//邻接表
    int[] ne = new int[M];//邻接表
    int[] w1 = new int[M];//邻接表
    int idx = 0;//邻接表

    int INF = 0x3f3f3f3f;
    boolean[] vis = new boolean[N];//是否被查询过
    int[] dist = new int[N];//距离


    public int networkDelayTime(int[][] times, int n_, int k_) {
        n = n_;
        k = k_;
        //初始化邻接矩阵
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++) {
                w[i][j] = w[j][i] = i == j ? 0 : INF;
            }
        }
        //存图
        for (int[] c : times) {
            int x = c[0], y = c[1], u = c[2];
            w[x][y] = Math.min(w[x][y], u);
        }

        //初始化邻接表
        Arrays.fill(he, -1);
        for (int[] c : times) {
            int x = c[0], y = c[1], u = c[2];
            add(x, y, u);
        }
        int ans = 0;
        //floyd();
/*        for (int i = 1; i <= n; i++) {
            ans = Math.max(ans, w[k][i]);
        }*/
/*        dijkstra();
        for (int i = 1; i <= n; i++) {
            ans = Math.max(ans, dist[i]);
        }*/

       /* dijkstra();
        for (int i = 1; i <= n; i++) {
            ans = Math.max(ans, dist[i]);
        }*/
        spfa();
        for (int i = 1; i <= n; i++) {
            ans = Math.max(ans, dist[i]);
        }
        return ans > INF / 2 ? -1 : ans;
    }


//Floyd
// 时间复杂度：O(n^3)
//空间复杂度：O(n^2)
/*    public void floyd(){
        // floyd 基本流程为三层循环：
        // 枚举中转点 - 枚举起点 - 枚举终点 - 松弛操作
        for(int p=1;p <= n; p++){
            for (int i = 1; i <=n; i++) {
                for (int j = 1; j <= n; j++) {
                    w[i][j]=Math.min(w[i][j], w[i][p]+w[p][j]);
                }
            }
        }
    }*/


//朴素 Dijkstra（邻接矩阵）
// 时间复杂度：O(n^2)
//空间复杂度：O(n^2)
/*    void dijkstra() {
        // 起始先将所有的点标记为「未更新」和「距离为正无穷」
        Arrays.fill(vis, false);
        Arrays.fill(dist, INF);
        // 只有起点最短距离为 0
        dist[k] = 0;
        // 迭代 n 次
        for (int i = 1; i <= n; i++) {
            int t = -1;
            // 每次找到「最短距离最小」且「未被更新」的点 t
            for (int j = 1; j <= n; j++) {
                if (!vis[j] && (t == -1 || dist[t] > dist[j])) {
                    t = j;
                }
            }
            // 标记点 t 为已更新
            vis[t] = true;
            // 用点 t 的「最小距离」更新其他点
            for (int j = 1; j <= n; j++) {
                dist[j] = Math.min(dist[j], dist[t] + w[t][j]);
            }
        }
    }*/


    void add(int a, int b, int c) {
        e[idx] = b;
        w1[idx] = c;//a到b的权值
        ne[idx] = he[a];
        he[a] = idx++;
    }

//堆优化版dijkstra
// 时间复杂度：O(mlogn+n)
//空间复杂度：O(m)
/*    void dijkstra() {
        // 起始先将所有的点标记为「未更新」和「距离为正无穷」
        Arrays.fill(vis, false);
        Arrays.fill(dist, INF);
        // 只有起点最短距离为 0
        dist[k] = 0;

        // 使用「优先队列」存储所有可用于更新的点
        // 以 (点编号, 到起点的距离) 进行存储，优先弹出「最短距离」较小的点
        PriorityQueue<int[]> q = new PriorityQueue<int[]>((a, b) -> a[1] - b[1]);
        q.add(new int[]{k, 0});

        while (!q.isEmpty()) {
            // 每次从「优先队列」中弹出
            int[] poll = q.poll();
            int id = poll[0];
            int step = poll[1];
            // 如果弹出的点被标记「已更新」，则跳过
            if (vis[id]) continue;
            // 标记该点「已更新」，并使用该点更新其他点的「最短距离」
            vis[id] = true;
            for (int i = he[id]; i != -1; i = ne[i]) {
                int j = e[i];
                if (dist[j] > dist[id] + w1[i]) {
                    dist[j] = dist[id] + w1[i];
                    q.add(new int[]{j, dist[j]});
                }
            }
        }
    }*/

//SPFA
// 时间复杂度：O(n*m)
//空间复杂度：O(m)
    void spfa() {
        // 起始先将所有的点标记为「未更新」和「距离为正无穷」
        Arrays.fill(vis, false);
        Arrays.fill(dist, INF);
        // 只有起点最短距离为 0
        dist[k] = 0;
        // 使用「双端队列」存储，存储的是点编号
        Deque<Integer> d = new ArrayDeque<Integer>();
        // 将「源点/起点」进行入队，并标记「已入队」
        d.addLast(k);
        vis[k] = true;
        while (!d.isEmpty()) {
            // 每次从「双端队列」中取出，并标记「未入队」
            int poll = d.pollFirst();
            vis[poll] = false;
            // 尝试使用该点，更新其他点的最短距离
            // 如果更新的点，本身「未入队」则加入队列中，并标记「已入队」
            for (int i = he[poll]; i != -1; i = ne[i]) {
                int j = e[i];
                if (dist[j] > dist[poll] + w1[i]) {
                    dist[j] = dist[poll] + w1[i];
                    if (vis[j]) continue;
                    d.addLast(j);
                    vis[j] = true;
                }
            }
        }
    }
}
```







### 最小生成树



#### Prim

- O(n^2)
- 稠密图
- 与dijkstra算法类似

```java
package 树与图;

import java.util.Arrays;
import java.util.Scanner;

public class Prim {
    public static int N = 510, INF = 0x3f3f3f3f;
    public static int n, m;
    public static int[][] g = new int[N][N];
    public static int[] dist = new int[N];
    public static boolean[] st = new boolean[N];

    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        n = input.nextInt();
        m = input.nextInt();
        for (int i = 0; i < N; i++) {
            Arrays.fill(g[i], INF);
        }
        for (int i = 0; i < m; i++) {
            int a = input.nextInt();
            int b = input.nextInt();
            int w = input.nextInt();
            g[a][b] = Math.min(g[a][b], w);
        }
        int t = prim();
        if (t == INF)
            System.out.println("impossible");
        else
            System.out.println(t);
    }

    public static int prim() {
        Arrays.fill(st, false);
        Arrays.fill(dist, INF);
        int res = 0;
        //迭代n次
        for (int i = 0; i < n; i++) {
            int t = -1;
            for (int j = 1; j <= n; j++) {
                //找到距离集合最近的点
                if (!st[j] && (t == -1 || dist[t] > dist[j])) {
                    t = j;
                }
            }
            //无法联通
            if (i > 0 && dist[t] == INF)
                return INF;
            //将这个距离加到总距离中
            //第一次的不用加
            if (i > 0) res += dist[t];
            st[t] = true;
            for (int k = 1; k <= n; k++) {
                //更新其他点的距离
                dist[k] = Math.min(dist[k], g[t][k]);
            }
        }
        return res;
    }
}
```







#### Kruskal

- 稀疏图
- O(mlogn)
- 运用到并查集

1. 将所有边按权重从小到大排序 O(mlogm)
2. 枚举每一条边，如果ab不连通，将ab加到集合中 O(m)

```java
package 树与图;

import java.util.Arrays;
import java.util.Comparator;
import java.util.Scanner;

public class Kruskal {
    public static int N = 10010;
    public static int n, m;
    public static int[] p;

    public static void main(String[] args) {

        Scanner input = new Scanner(System.in);
        n = input.nextInt();
        m = input.nextInt();
        p = new int[n + 1];
        Edge[] edges = new Edge[m];
        for (int i = 0; i < m; i++) {
            int a = input.nextInt();
            int b = input.nextInt();
            int c = input.nextInt();
            edges[i] = new Edge(a, b, c);
        }
        //按照w进行排序
        //lambda表达式
        Arrays.sort(edges, (a, b) -> {
            return a.w - b.w;
        });
        //将每个点的父亲节点设为自己
        for (int i = 1; i <= n; i++) p[i] = i;

        int res = 0;//所有边的和
        int cnt = 0;//数量
        for (int i = 0; i < m; i++) {
            //找父亲节点
            int a = find(edges[i].a);
            int b = find(edges[i].b);
            //父亲节点不一样
            if (a != b) {
                res += edges[i].w;
                cnt++;
                //a和b指向同一个集合
                p[a] = b;
            }
        }
        if (cnt < n - 1)
            System.out.println("impossible");
        else
            System.out.println(res);
    }

    public static int find(int x) {
        if (p[x] != x) p[x] = find(p[x]);
        return p[x];
    }
}
```



### 二分图

**当且仅当图中不含奇数环**

#### 染色法

- O(n+m)
- 一条边的两个点属于不同集合
- 由于图中不含奇数环，染色过程中没有矛盾
- 更多用于判断是否为二分图



<img src="../../typora/image/image-20211120194459065.png" alt="image-20211120194459065" style="zoom: 80%;" />



```java
package 树与图;

import java.util.Scanner;

public class 染色法_二分图 {

    private static int N = 100010, M = 200020;//N为点的个数，M为边的个数，因为为有向图
    private static int[] ne = new int[M], e = new int[M], h = new int[N];//邻接矩阵
    private static int idx;
    private static int[] color = new int[N];//表示这个点是否被染色

    public static void main(String[] args) {
        int n, m;
        Scanner input = new Scanner(System.in);
        n = input.nextInt();
        m = input.nextInt();
        while (m-- > 0) {
            int a = input.nextInt();
            int b = input.nextInt();
            add(a, b);
            add(b, a);
        }
        //判断是否能成功染色
        //能成功染色说明是二分图
        boolean flag = true;
        for (int i = 1; i <= n; i++) {
            if (color[i] == 0) {
                if (!dfs(i, 1)) {
                    flag = false;
                    break;
                }
            }
        }
        if (flag) {
            System.out.println("Yes");
        } else {
            System.out.println("No");
        }
    }

    //u表示当前点，c表示颜色
    private static boolean dfs(int u, int c) {
        color[u] = c;
        for (int i = h[u]; i != -1; i = ne[i]) {
            int j = e[i];
            if (color[j] == 0) {
                //颜色只有1和2，所以用3-c;
                if (!dfs(j, 3 - c))
                    return false;
            } else if (color[j] == c) {
                return false;
            }
        }
        return true;
    }

    private static void add(int a, int b) {
        e[idx] = b;
        ne[idx] = h[a];
        h[a] = idx++;
    }
}
```





#### 匈牙利算法

- O(nm)
- 更多用于二分图的最大匹配



<img src="../../typora/image/image-20211120202114362.png" alt="image-20211120202114362" style="zoom:80%;" />



```java
package 树与图;

import java.util.Arrays;
import java.util.Scanner;

public class 匈牙利_二分图 {
    private static int N = 500, M = 200020;//N为点的个数，M为边的个数，因为为有向图
    private static int[] ne = new int[M], e = new int[M], h = new int[N];//邻接矩阵
    private static int idx;
    private static int[] match = new int[N];//记录当前右侧元素所对应的左侧元素
    private static boolean[] st = new boolean[N];//记录右侧元素是否已被访问过

    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        int n1 = input.nextInt();
        int n2 = input.nextInt();
        int m = input.nextInt();
        Arrays.fill(h, -1);
        while (m-- > 0) {
            int a = input.nextInt();
            int b = input.nextInt();
            add(a, b);
        }

        int res = 0;
        for (int i = 1; i <= n1; i++) {
            Arrays.fill(st, false);
            if (KM(i)) res++;
        }
        System.out.println(res);
    }

    public static boolean KM(int u) {
        for (int i = h[u]; i != -1; i++) {
            int j = e[i];
            if (!st[j]) {
                st[j] = true;
                //如果暂无匹配，或者原来匹配的左侧元素可以找到新的匹配
                if (match[j] == 0 || KM(match[j])) {
                    match[j] = u;//记录当前右侧元素所对应的左侧元素
                    return true;
                }
            }
        }
        return false;

    }

    private static void add(int a, int b) {
        e[idx] = b;
        ne[idx] = h[a];
        h[a] = idx++;
    }
}
```









## 动态规划

- 状态表示
- 状态计算

### 背包问题



#### **01背包**

**所有物品不可再分，要么整个装入背包，要么放弃，不允许出现“仅选择物品的 1/3 装入背包”的情况；**

![image-20211122152051704](../../typora/image/image-20211122152051704.png)

[01背包](https://www.acwing.com/problem/content/description/2/)

```java
package 动态规划;

import java.util.Scanner;

public class 背包_01 {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        int n = input.nextInt();//n件物品
        int m = input.nextInt();//背包容量
        int[] w=new int[n+1];//物品价值
        int[] v = new int[n+1];//物品体积
        int[][] f=new int[n+1][m+1];
        for (int i = 1; i <= n; i++) {
            v[i] = input.nextInt();
            w[i] = input.nextInt();
        }
        for(int i=1;i <= n; i++){
            for(int j=1;j<=m; j++){
                f[i][j]=f[i-1][j];
                if(j>=v[i])
                    f[i][j] = Math.max(f[i][j],f[i-1][j-v[i]]+w[i]);
            }
        }
        System.out.println(f[n][m]);
    }
}
```

```c++
#include<bits/stdc++.h>

using namespace std;

const int MAXN = 1005;
int f[MAXN];  // 

int main() 
{
    int n, m;   
    cin >> n >> m;

    for(int i = 1; i <= n; i++) {
        int v, w;
        cin >> v >> w;      // 边输入边处理
        for(int j = m; j >= v; j--)
            f[j] = max(f[j], f[j - v] + w);
    }

    cout << f[m] << endl;

    return 0;
}

```



#### **完全背包**

**不对每一件物品的数量做限制，同一件物品可以选择多个装入背包**

朴素

<img src="../../typora/image/image-20211122151113154.png" alt="image-20211122151113154" style="zoom: 50%;" />



优化

<img src="../../typora/image/image-20211122151709248.png" alt="image-20211122151709248" style="zoom: 67%;" />

[完全背包](https://blog.csdn.net/wumuzi520/article/details/7014830)

```java
package 动态规划;

import java.util.Scanner;

public class 背包_完全 {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        int n = input.nextInt();//n件物品
        int m = input.nextInt();//背包容量
        int[] w=new int[n+1];//物品价值
        int[] v = new int[n+1];//物品体积
        int[][] f=new int[n+1][m+1];
        for (int i = 1; i <= n; i++) {
            v[i] = input.nextInt();
            w[i] = input.nextInt();
        }
        for(int i=1;i <= n; i++){
            for(int j=1;j<=m; j++){
                f[i][j]=f[i-1][j];
                if(j>=v[i])
                    f[i][j] = Math.max(f[i][j],f[i][j-v[i]]+w[i]);
            }
        }
        System.out.println(f[n][m]);
    }
}
```



一维

```java
package 动态规划;

import java.util.Scanner;

public class 背包_完全 {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        int n = input.nextInt();//n件物品
        int m = input.nextInt();//背包容量
        int[] w = new int[n + 1];//物品价值
        int[] v = new int[n + 1];//物品体积
        int[] f = new int[m + 1];
        for (int i = 1; i <= n; i++) {
            v[i] = input.nextInt();
            w[i] = input.nextInt();
        }
        for (int i = 1; i <= n; i++) {
            for (int j = v[i]; j <= m; j++) {
                f[j] = Math.max(f[j], f[j - v[i]] + w[i]);
            }
            System.out.println(f[m]);
        }
    }
}

```





#### **分组背包**

**所有物品是可再分的**

[分组背包](https://www.acwing.com/problem/content/9/)

```java
package 动态规划;

import java.util.Scanner;

public class 背包_分组 {
    private static int N = 150;
    public static int[][] v = new int[N][N];
    public static int[][] w = new int[N][N];
    public static int[] s = new int[N];
    public static int[] f = new int[N];

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int m = sc.nextInt();
        for (int i = 1; i <= n; i++) {
            s[i] = sc.nextInt();
            for (int k = 1; k <= s[i]; k++) {
                v[i][k] = sc.nextInt();
                w[i][k] = sc.nextInt();
            }
        }
        for (int i = 1; i <= n; i++) {
            for (int j = m; j >= 0; j--) {
                for (int k = 1; k <= s[i]; k++) {
                    if (v[i][k] <= j) {
                        f[j] = Math.max(f[j], f[j - v[i][k]] + w[i][k]);
                    }
                }
            }
        }
        System.out.println(f[m]);
    }
}
```





#### **多重背包**

**每件物品的数量是有严格规定的，比如物品 A 有 2 件，物品 B 有 3 件。**

![image-20211122183525845](../../typora/image/image-20211122183525845.png)

**将多重背包蜕化成零一背包**：**二进制表示法**

[多重背包](https://www.acwing.com/problem/content/5/)

```java
package 动态规划;

import java.util.Scanner;

public class 背包_多重 {
    public static int N = 25000, M = 2010;
    public static int[] v = new int[N];
    public static int[] w = new int[N];
    public static int[] f = new int[N];

    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        int n = input.nextInt();
        int m = input.nextInt();
        int cnt = 0;//所分成的份数
        for (int i = 0; i < n; i++) {
            int a = input.nextInt();
            int b = input.nextInt();
            int s = input.nextInt();
            int k = 1;
            //二进制计数
            while (k <= s) {
                cnt++;
                v[cnt] = k * a;
                w[cnt] = k * b;
                s -= k;
                k *= 2;
            }
            //还有剩余
            if (s > 0) {
                cnt++;
                v[cnt] = s * a;
                w[cnt] = s * b;
            }
        }
        //最后分出来的份数
        n = cnt;
        for (int i = 1; i <= n; i++) {
            for (int j = m; j >= v[i]; j--) {
                f[j] = Math.max(f[j], f[j - v[i]] + w[i]);
            }
        }
        System.out.println(f[m]);
    }
}
```





### 线性DP





[数字三角形](https://www.acwing.com/problem/content/900/)

- 每个点当前的状态为左上角+当前位置值与右上角+当前位置的值的最大值

```java
package 动态规划;

import java.util.Arrays;
import java.util.Scanner;

public class 数字三角形 {
    public static int N = 510;
    public static int[][] a = new int[N][N];
    public static int[][] f = new int[N][N];

    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        int n = input.nextInt();
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= i; j++) {
                a[i][j] = input.nextInt();
            }
        }
        //初始化，因为数据中有负数，所以初始的0不符合条件
        for (int i = 0; i <= n; i++) {
            Arrays.fill(f[i], Integer.MIN_VALUE);
        }
        f[1][1] = a[1][1];
        //从第二行第一列开始
        for (int i = 2; i <= n; i++) {
            for (int j = 1; j <= n; j++) {
                f[i][j] = Math.max(f[i - 1][j - 1], f[i - 1][j]) + a[i][j];
            }
        }
        int max = Integer.MIN_VALUE;
        //遍历最后一行，因为最后一行的所有数据都有可能
        for (int i = 1; i <= n; i++) {
            max = Math.max(max, f[n][i]);
        }
        System.out.println(max);
    }
}
```





[最长上升子序列](https://www.acwing.com/problem/content/897/)

- f[i]为所有以第i个数结尾的上升子序列
- 从前往后找子序列，如果符合条件，则将当前数加入到子序列中
- 如果要输出子序列，则添加转移数组，记录转移坐标。
- 常规的时间复杂度为n^2,
- 用二分优化后的时间复杂度为nlogn
- [相关资料](https://blog.csdn.net/lxt_Lucia/article/details/81206439)

```java
package 动态规划;

import java.util.Scanner;

public class 最长上升子序列 {
    public static int N = 1010;
    public static int[] f = new int[N];//状态
    public static int[] a = new int[N];//整个序列
    public static int[] g = new int[N];//转移数组
//n^2时间复杂度
    /*public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        int n = input.nextInt();
        for (int i = 1; i <= n; i++) {
            a[i] = input.nextInt();
            f[i] = 1;//只有第i个数
            g[i] = 0;
            //从前往后遍历，如果有符合条件的子序列，则将当前数加入子序列
            for (int j = 1; j < i; j++) {
                if (a[j] < a[i]) {
                    if (f[j] + 1 > f[i]) {
                        f[i] = f[j] + 1;
                        g[i] = j;//记录转移坐标
                    }
                }
            }
        }
        int k = 1;
        for (int i = 1; i <= n; i++) {
            if (f[i] > f[k])
                k = i;
        }
        System.out.println(f[k]);
        //子序列逆序输出
        while (g[k] != 0) {
            System.out.println(a[k]);
            k = g[k];
        }
    }*/

    //nlogn时间复杂度
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        int n = input.nextInt();
        for (int i = 1; i <= n; i++) {
            a[i] = input.nextInt();
        }
        int cnt = 0;
        f[cnt++] = a[1];
        for (int i = 2; i <= n; i++) {
            //如果当前数大于子序列最后一个数，则加到末尾
            if (a[i] > f[cnt - 1]) f[cnt++] = a[i];
                //否则用二分查找的方式找到子序列中第一个比a[i]大的数，并将a[i]替换到这个位置
            else {
                int l = 0, r = cnt - 1;
                while (l < r) {
                    int mid = l + r >> 1;
                    if (f[mid] >= a[i]) {
                        r = mid;
                    } else {
                        l = mid + 1;
                    }
                }
                //替换
                f[r] = a[i];
            }
        }
        System.out.println(cnt);
    }
}


```





[最长公共子序列](https://www.acwing.com/problem/content/899/)

<img src="../../typora/image/image-20211123123451377.png" alt="image-20211123123451377" style="zoom: 50%;" />



- f [i，j]：所有在第一个子序列前i个字符中出现，在第二个子序列前j个字符中出现的子序列
- 



```java
package 动态规划;

import java.sql.NClob;
import java.util.Scanner;

public class 最长公共子序列 {
    public static int N = 1010;
    public static char[] a = new char[N], b = new char[N];
    public static int[][] f = new int[N][N];

    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        int n = input.nextInt();
        int m = input.nextInt();
        String s=input.next();
        for (int i = 1; i <= n; i++)
            a[i] = s.charAt(i-1);
        String s1=input.next();
        for (int i = 1; i <= m; i++)
            b[i] = s1.charAt(i-1);
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                f[i][j] = Math.max(f[i - 1][j], f[i][j - 1]);
                if (a[i] == b[j])
                    f[i][j] = Math.max(f[i][j], f[i - 1][j - 1] + 1);
            }
        }
        System.out.println(f[n][m]);
    }
}
```







### 区间DP





[石子合并](https://www.acwing.com/problem/content/284/)

<img src="../../typora/image/image-20211123202242679.png" alt="image-20211123202242679" style="zoom:50%;" />

- 将f[i,j] 分成k类

- 枚举最后一次合并

- 按照从小到大进行枚举

  ```java
  package 动态规划;
  
  import java.util.Map;
  import java.util.Scanner;
  
  public class 石子合并 {
      public static int N = 310;
  
      public static void main(String[] args) {
          Scanner input = new Scanner(System.in);
          int n = input.nextInt();
          int[] s = new int[n + 1];
          int[][] f = new int[n + 1][n + 1];
          for (int i = 1; i <= n; i++) {
              s[i] = input.nextInt();
              s[i] = s[i] + s[i - 1];
          }
          //先枚举整个区间的长度
          //区间长度为1的话，就为本身，没必要枚举
          for (int len = 2; len <= n; len++) {
              for (int i = 1; i + len - 1 <= n; i++) {
                  int l = i, r = i + len - 1;
                  f[i][r]=Integer.MAX_VALUE;
                  for (int k = l; k < r; k++) {
                      f[i][r] = Math.min(f[i][r], f[i][k] + f[k + 1][r] + s[r] - s[i - 1]);
                  }
              }
          }
          System.out.println(f[1][n]);
      }
  }
  ```





### 数位DP



[计数问题](https://www.acwing.com/problem/content/455/)

<img src="../../typora/image/image-20211123212654331.png" alt="image-20211123212654331" style="zoom:67%;" />

<img src="../../typora/image/image-20211124211031102.png" alt="image-20211124211031102" style="zoom:50%;" />



```java
package 动态规划;
import java.util.Scanner;

public class 计数问题 {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        int a = input.nextInt();
        int b = input.nextInt();
        int x = input.nextInt();
        int res = count(b, x) - count(a - 1, x);
        System.out.println(res);
    }

    public static int count(int num, int x) {
        int res = 0;
        int d = dgt(num);
        for (int j = d; j >= 1; j--) {
            int p = power10(j - 1);
            // l和r是第j位左边和右边的整数
            int l = num / p / 10;
            int r = num % p;
            //第j位数字
            int now = num / p % 10;
            // 计算第j位左边的整数小于l (视频中xxx = 000 ~ abc - 1)的情况
            if (x != 0) res += l * p;
            // 如果x = 0, 左边高位不能全为0(视频中xxx = 001 ~ abc - 1)
            if (x == 0 && l != 0) res += (l - 1) * p;
            // 计算第j位左边的整数等于l (视频中xxx = abc)的情况
            if (now > x && (x != 0 || l != 0)) res += p;
            if (now == x && (x != 0 || l != 0)) res += r + 1;
        }
        return res;
    }
    //计算十的k次方
    public static int power10(int k) {
        int res = 1;
        while (k-- > 0) {
            res *= 10;
        }
        return res;
    }

    public static int dgt(int n) // 计算整数n有多少位
    {
        int res = 0;
        while (n != 0) {
            ++res;
            n /= 10;
        }
        return res;
    }
}
```



### 状态压缩

- 将整数看成二进制数



[铺砖](https://www.acwing.com/problem/content/293/)

- f [i] [j] 表示第i列伸出来时的j状态





[最短Hamilton路径](https://www.acwing.com/problem/content/93/)

- f [i] [j] 从0走到j,走过所有点是i

```java
package 动态规划;

import java.util.Arrays;
import java.util.Scanner;

public class 最短Hamilton {
    public static int N = 21, M = 1 << N;
    public static int[][] dp = new int[M][N];
    public static int[][] w = new int[N][N];

    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        int n = input.nextInt();
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                w[i][j] = input.nextInt();
            }
        }
        for(int i=0;i<M; i++){
            Arrays.fill(dp[i],0x3f3f3f3f);
        }
        dp[1][0]=0;
        for (int i = 0; i < 1 << n; i++) {
            for (int j = 0; j < n; j++) {
                //j在该路径内
                if (((i >> j) & 1) != 0) {
                    for (int k = 0; k < n; k++) {
                        //k在该路径内
                        if (((i - (1 << j) >> k) & 1)!= 0) {
                            dp[i][j] = Math.min(dp[i][j], dp[i - (1 << j)][k] +w[k][j]);

                        }
                    }
                }
            }
        }
        System.out.println(dp[(1 << n) - 1][n - 1]);
    }
}
```





### 树状DP





[没有上司的舞会](https://www.acwing.com/problem/content/287/)

- 状态表示：f[u] [0]:所有以u为根的子树中选择，并且不选择u；f[u] [1] 所有以u为根的子树中选择，并且选择u
- <img src="../../typora/image/image-20211124171108700.png" alt="image-20211124171108700" style="zoom:50%;" />

- 时间O(n)

```java
package 动态规划;

import java.util.Arrays;
import java.util.Scanner;

public class 树状DP {
    public static int N = 6010;
    public static boolean[] has_father = new boolean[N];//有父亲节点
    public static int[] h = new int[N], ne = new int[N], e = new int[N];
    public static int idx;
    public static int n;
    public static int[] happy;//快乐指数
    public static int[][] f = new int[N][2];

    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        n = input.nextInt();
        happy = new int[n+1];
        Arrays.fill(h,-1);
        for (int i = 1; i <= n; i++) happy[i] = input.nextInt();
        for (int i = 0; i < n-1; i++) {
            int a = input.nextInt();
            int b = input.nextInt();
            has_father[a] = true;
            add(b, a);
        }
        int root = 1;
        //找到根节点
        while (has_father[root]) root++;
        dfs(root);
        System.out.println(Math.max(f[root][0],f[root][1]));
    }

    public static void add(int a, int b) {
        e[idx] = b;
        ne[idx] = h[a];
        h[a] = idx++;
    }

    public static void dfs(int u) {
        f[u][1] += happy[u];
        //找子节点
        for (int i = h[u]; i != -1; i = ne[i]) {
            int j = e[i];
            //先计算子节点
            dfs(j);
            f[u][0] += Math.max(f[j][0], f[j][1]);
            f[u][1] += f[j][0];
        }
    }
}
```







### 记忆化搜索





[滑雪](https://www.acwing.com/problem/content/903/)



- 状态表示：f[i] [j] 表示从i，j 开始的路径
- 

```java
package 动态规划;

import java.util.Arrays;
import java.util.Scanner;

public class 记忆化搜索 {
    public static int[][] h;
    public static int[][] find;
    public static int R, C;
    public static int[] dir = {1, 0, -1, 0, 1};

    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        R = input.nextInt();
        C = input.nextInt();
        h = new int[R + 1][C + 1];
        find = new int[R + 1][C + 1];
        for (int i = 1; i <= R; i++) {
            Arrays.fill(find[i], -1);
            for (int j = 1; j <= C; j++) {
                h[i][j] = input.nextInt();
            }
        }
        int res = 0;
        for (int i = 1; i <= R; i++) {
            for (int j = 1; j <= C; j++) {
                res = Math.max(res, dp(i, j));
            }
        }
        System.out.println(res);
    }

    public static int dp(int x, int y) {
        //已经递归寻找过，不用再递归
        if (find[x][y] != -1) return find[x][y];
        //最少步数为1
        find[x][y] = 1;
        //遍历四个方向
        for (int k = 0; k < 4; k++) {
            int a = x + dir[k];
            int b = y + dir[k + 1];
            if (a >= 1 && a <= R && b >= 1 && b <= C && h[a][b] < h[x][y])
                find[x][y] = Math.max(find[x][y], dp(a, b) + 1);
        }
        return find[x][y];
    }
}
```







## 贪心



**区间选点**

<img src="../../typora/image/image-20211124214147031.png" alt="image-20211124214147031" style="zoom:67%;" />



1. 按区间右端点从小到大排序
2. 从前往后一次枚举整个区间。如果当前区间已经包含点，pass；否则选择区间右端点

```java
package 贪心;

import java.util.*;

public class 区间选点 {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        int n = input.nextInt();
        List<int[]> ans = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            int l = input.nextInt();
            int r = input.nextInt();
            ans.add(new int[]{l, r});
        }
        //按右端点排序
        Collections.sort(ans, (a, b) -> {
            return a[1] - b[1];
        });
        int pre = Integer.MIN_VALUE;
        int res = 0;
        for (int i = 0; i < n; i++) {
            if (ans.get(i)[0] > pre) {
                res++;
                pre = ans.get(i)[1];
            }
        }
        System.out.println(res);
    }
}
```





**区间选组**

<img src="../../typora/image/image-20211124221350440.png" alt="image-20211124221350440" style="zoom:50%;" />



```java
package 贪心;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Scanner;

public class 区间分组 {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        int n = input.nextInt();
        List<int[]> ans = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            int l = input.nextInt();
            int r = input.nextInt();
            ans.add(new int[]{l, r});
        }
        //左端点
        Collections.sort(ans, (a, b) -> {
            return a[0] - b[0];
        });
        int r=0;
        int res=1;
        for(int i=0;i<n; i++){
            if(ans.get(i)[0]>r){
                res++;
            }
            r=Math.max(r,ans.get(i)[1]);
        }
        System.out.println(res);
    }
}
```





**区间覆盖**

<img src="../../typora/image/image-20211125160303267.png" alt="image-20211125160303267" style="zoom: 67%;" />



```java
package 贪心;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Scanner;

public class 区间覆盖 {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        int l = input.nextInt();
        int r = input.nextInt();
        int n = input.nextInt();
        List<int[]> ans=new ArrayList<int[]>();
        for (int i = 0; i < n; i++) {
            int a = input.nextInt();
            int b = input.nextInt();
            ans.add(new int[]{a,b});
        }
        Collections.sort(ans,(a,b)->{
            return a[0]-b[0];
        });
        int res=0;
        boolean f=false;
        for(int i = 0; i < n; i++){
            int j=i;
            int maxr=Integer.MIN_VALUE;
            //找到所有左端点比起点小的区间的最大值
            while (j<n&&ans.get(j)[0]<=l){
                maxr=Math.max(maxr, ans.get(j)[1]);
                j++;
            }
            //找不到任何点
            if(j==i){
                System.out.println(-1);
                return;
            }
            res++;
            if(maxr>=r) {
                f=true;
                break;
            }
            //将区间左端点变成当前所能到达的最大右端点
            l=maxr;
            i=j-1;
        }
        if(!f) res=-1;
        System.out.println(res);
    }
}
```





**Haffman树**

- 深度最深的两个节点，深度一定最深，且可以互为兄弟

[合并果子](https://www.acwing.com/problem/content/150/)

```java
package 贪心;

import java.util.PriorityQueue;
import java.util.Scanner;

public class 合并果子 {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        int n = input.nextInt();
        PriorityQueue<Integer> q = new PriorityQueue<Integer>(n);
        for(int i = 0; i < n; i++){
            int a = input.nextInt();
            q.add(a);
        }
        int res=0;
        while(q.size() > 1){
            int a=q.poll();
            int b=q.poll();
            res+=a+b;
            q.add(a+b);
        }
        System.out.println(q.poll());
    }
}
```





**打水问题**

<img src="../../typora/image/image-20211125165602286.png" alt="image-20211125165602286" style="zoom:67%;" />



- 从小到大排序，然后计算便可





[仓库选址](https://www.acwing.com/problem/content/106/)

![image-20211125170955042](../../typora/image/image-20211125170955042.png)

